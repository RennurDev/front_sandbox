<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Sample Map | trace : tracking user locations</title>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, shrink-to-fit=no">
<meta name="description" content="Mapbox GL JS 地図上にユーザーの位置情報履歴を、ラインで表示する">
<meta property="og:type" content="website">
<meta property="og:title" content="Sample Map | trace : tracking user locations">
<meta property="og:locale" content="ja_JP">
<meta property="article:author" content="isnot">
<link rel="stylesheet" type="text/css" href="https://unpkg.com/sakura.css/css/sakura.css">
<link rel="stylesheet" type="text/css" type="text/css" href="https://api.mapbox.com/mapbox-gl-js/v2.1.1/mapbox-gl.css">
<style>
  #map { height: 600px; }
</style>
</head>
<body>
  <div id="container">
    <header class="article-header">
      <h1>Sample Map | trace : tracking user locations</h1>
    </header>
    <div class="article">
      <p class="repository">see also <a href="https://github.com/isnot/my-mapbox-samples">GitHub/isnot/my-mapbox-samples</a></p>
      <div id="map"></div>
      <script src="https://api.mapbox.com/mapbox-gl-js/v2.1.1/mapbox-gl.js"></script>
      <script>

class userLocationHistory {
  constructor() {
    this.history = [];
    this.previous_location = undefined;
    this.min_duration = 2;
  } // state に描きかえる

  _hasProperty(obj, prop) {
    return Object.prototype.hasOwnProperty.call(obj, prop);
  }

  _add(geolocate) {
    if (this._hasProperty(geolocate, 'timestamp')) {
      console.log(geolocate);
      this.history.push([geolocate.coords.longitude, geolocate.coords.latitude])
      this.previous_location = geolocate;
    }
  }

  addGeolocate(geolocate) {
    if (this.previous_location != undefined) {
      const elapseTime = praseInt((geolocate.timestamp - this.previous_location.timestamp))
    }

    if (this.previous_location === undefined) {
      this._add(geolocate); // 測り始め
    } else if (elapseTime > this.min_duration) {
      this._add(geolocate); // 経過時間が設定した制限時間をこえたらヒストリ追加
    } else {
      return;
    }
  }

  getUserTrack() {
    const t = []
    for (const item of this.history) {
      t.push([item.coords.longitude, item.coords.latitude]);
      console.log(t)
    }
    return t;
  }
}

const userTrack = new userLocationHistory();
const geolocate = new mapboxgl.GeolocateControl({
  positionOptions: {
    enableHighAccuracy: true
  },
  trackUserLocation: true
});

mapboxgl.accessToken = 'pk.eyJ1IjoiaXNub3QiLCJhIjoiY2tkemV4MnR2MXRyMDJ4a2pzd2h1eHg1ayJ9.ALgtUeaHBDuvqvOR7008vA';

const map = new mapboxgl.Map({
  container: 'map',
  style: 'mapbox://styles/mapbox/streets-v11',
  minZoom: 4,
  localIdeographFontFamily: "'Noto Sans CJK JP', 'Noto Sans', sans-serif"
});

function setupGeoLine() {
  map.addSource('route', {
    'type': 'geojson',
    'data': {
      'type': 'Feature',
      'properties': {},
      'geometry': {
        'type': 'LineString',
        'coordinates': []
      }
    }
  });
  map.addLayer({
    'id': 'route',
    'type': 'line',
    'source': 'route',
    'layout': {
      'line-join': 'round',
      'line-cap': 'round'
    },
    'paint': {
      'line-color': '#888',
      'line-width': 4
    }
  });
}

function updateGeoLine(coordinates) {
  map.getSource('route').setData({
    'type': 'Feature',
    'properties': {},
    'geometry': {
      'type': 'LineString',
      'coordinates': coordinates
    }
  });
}

function onGeolocate(pos) {
  userTrack.addGeolocate(pos);
  console.log("USERTRACK_HISTORY IS")
  console.log(userTrack.history);
  updateGeoLine(userTrack.history);
}
map.addControl(geolocate);
geolocate.on('geolocate', onGeolocate);

map.on('load', () => {
  setupGeoLine();
});
      </script>
    </div>
  </div>
</body>
</html>
